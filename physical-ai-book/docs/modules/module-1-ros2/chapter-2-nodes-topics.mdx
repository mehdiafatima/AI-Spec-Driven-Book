---
sidebar_position: 2
---

# Chapter 2: ROS 2 Nodes and Topics

This chapter delves deeper into two fundamental concepts of ROS 2: **Nodes** and **Topics**. Understanding how these components work together is crucial for building any non-trivial ROS 2 application. We will cover their definitions, creation, communication mechanisms, and practical examples.

## ROS 2 Nodes: The Building Blocks of Robotics Software

As introduced in Chapter 1, a ROS 2 **node** is an executable process that performs computation. Think of nodes as individual programs or modules in your robotics system. Each node should ideally be responsible for a single, well-defined task.

### Why use Nodes?

-   **Modularity**: Breaking down a complex system into smaller, independent nodes makes development, debugging, and maintenance easier.
-   **Reusability**: Nodes can be reused across different projects or robot platforms.
-   **Distribution**: Nodes can run on different processors, different machines, or even different operating systems, communicating seamlessly.
-   **Fault Tolerance**: If one node crashes, it doesn't necessarily bring down the entire system.

### Creating a Simple ROS 2 Node (Python)

Let's create a basic Python node that prints "Hello, ROS 2!"

1.  **Create a ROS 2 package**:
    ```bash
    cd ~/ros2_ws/src
    ros2 pkg create --build-type ament_python my_python_pkg
    ```
    This creates a directory `my_python_pkg` with basic package structure.
2.  **Navigate to the package source directory**:
    ```bash
    cd my_python_pkg/my_python_pkg
    ```
3.  **Create a Python file (`hello_node.py`)**:
    ```python
    import rclpy
    from rclpy.node import Node

    class HelloNode(Node):

        def __init__(self):
            super().__init__('hello_node')
            self.get_logger().info('Hello, ROS 2 from a node!')

    def main(args=None):
        rclpy.init(args=args)
        hello_node = HelloNode()
        rclpy.spin(hello_node) # Keep the node alive
        hello_node.destroy_node()
        rclpy.shutdown()

    if __name__ == '__main__':
        main()
    ```
4.  **Edit `setup.py`**: Add an entry point for your script in `my_python_pkg/setup.py`. Find the `entry_points` dictionary and add:
    ```python
    entry_points={
        'console_scripts': [
            'hello_node = my_python_pkg.hello_node:main',
        ],
    },
    ```
5.  **Build your workspace**:
    ```bash
    cd ~/ros2_ws
    colcon build
    source install/setup.bash # Source after build
    ```
6.  **Run your node**:
    ```bash
    ros2 run my_python_pkg hello_node
    ```
    You should see the message "Hello, ROS 2 from a node!".

## ROS 2 Topics: Asynchronous Data Flow

**Topics** are the most common way for nodes to exchange data. They enable an asynchronous, publish-subscribe communication model.

-   **Publisher**: A node that sends messages to a topic.
-   **Subscriber**: A node that receives messages from a topic.
-   **Message Type**: Every topic has a specific message type, defining the structure of the data being transmitted.

### Standard Message Types

ROS 2 provides a wide range of standard message types for common data, such as `std_msgs` (e.g., `String`, `Int32`), `geometry_msgs` (e.g., `Point`, `Twist`), `sensor_msgs` (e.g., `Image`, `LaserScan`), etc.

### Creating a Simple ROS 2 Publisher (Python)

Let's modify our `my_python_pkg` to include a talker node that publishes string messages.

1.  **Create `simple_publisher.py` in `my_python_pkg/my_python_pkg`**:
    ```python
    import rclpy
    from rclpy.node import Node
    from std_msgs.msg import String # Import the message type

    class SimplePublisher(Node):

        def __init__(self):
            super().__init__('simple_publisher')
            self.publisher_ = self.create_publisher(String, 'chatter', 10) # Topic name: 'chatter', QoS: 10
            timer_period = 0.5  # seconds
            self.timer = self.create_timer(timer_period, self.timer_callback)
            self.i = 0

        def timer_callback(self):
            msg = String()
            msg.data = f'Hello from SimplePublisher: {self.i}'
            self.publisher_.publish(msg)
            self.get_logger().info(f'Publishing: "{msg.data}"')
            self.i += 1

    def main(args=None):
        rclpy.init(args=args)
        simple_publisher = SimplePublisher()
        rclpy.spin(simple_publisher)
        simple_publisher.destroy_node()
        rclpy.shutdown()

    if __name__ == '__main__':
        main()
    ```
2.  **Edit `setup.py`**: Add another entry point:
    ```python
    entry_points={
        'console_scripts': [
            'hello_node = my_python_pkg.hello_node:main',
            'simple_publisher = my_python_pkg.simple_publisher:main', # New entry
        ],
    },
    ```
3.  **Build and source your workspace**:
    ```bash
    cd ~/ros2_ws
    colcon build
    source install/setup.bash
    ```
4.  **Run your publisher**:
    ```bash
    ros2 run my_python_pkg simple_publisher
    ```

### Creating a Simple ROS 2 Subscriber (Python)

Now, let's create a listener node that subscribes to the 'chatter' topic.

1.  **Create `simple_subscriber.py` in `my_python_pkg/my_python_pkg`**:
    ```python
    import rclpy
    from rclpy.node import Node
    from std_msgs.msg import String # Import the message type

    class SimpleSubscriber(Node):

        def __init__(self):
            super().__init__('simple_subscriber')
            self.subscription = self.create_subscription(
                String,
                'chatter',
                self.listener_callback,
                10) # Topic name: 'chatter', QoS: 10
            self.subscription  # prevent unused variable warning

        def listener_callback(self, msg):
            self.get_logger().info(f'I heard: "{msg.data}"')

    def main(args=None):
        rclpy.init(args=args)
        simple_subscriber = SimpleSubscriber()
        rclpy.spin(simple_subscriber)
        simple_subscriber.destroy_node()
        rclpy.shutdown()

    if __name__ == '__main__':
        main()
    ```
2.  **Edit `setup.py`**: Add another entry point:
    ```python
    entry_points={
        'console_scripts': [
            'hello_node = my_python_pkg.hello_node:main',
            'simple_publisher = my_python_pkg.simple_publisher:main',
            'simple_subscriber = my_python_pkg.simple_subscriber:main', # New entry
        ],
    },
    ```
3.  **Build and source your workspace**:
    ```bash
    cd ~/ros2_ws
    colcon build
    source install/setup.bash
    ```
4.  **Run both publisher and subscriber (in separate terminals)**:
    -   Terminal 1: `ros2 run my_python_pkg simple_publisher`
    -   Terminal 2: `ros2 run my_python_pkg simple_subscriber`
    You should see the subscriber receiving and printing the messages published by the publisher.

## Inspecting ROS 2 Communication

ROS 2 provides command-line tools to inspect your running system.

-   **`ros2 node list`**: Lists all active nodes.
-   **`ros2 topic list`**: Lists all active topics.
-   **`ros2 topic info <topic_name>`**: Shows information about a specific topic (message type, publishers, subscribers).
-   **`ros2 topic echo <topic_name>`**: Displays messages being published on a topic in real-time.
-   **`ros2 topic pub <topic_name> <message_type> <args>`**: Publishes a single message to a topic from the command line.

Try these commands while your publisher and subscriber nodes are running.

## Conclusion

Nodes and Topics form the backbone of ROS 2 communication. By understanding how to create and manage these, you can begin to architect more complex robotic systems. The next chapter will explore Services and Actions, providing synchronous communication patterns and handling long-running tasks.
